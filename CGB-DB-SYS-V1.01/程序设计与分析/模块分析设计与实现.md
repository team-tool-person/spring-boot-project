# 模块分析设计与实现 #

# 1.日志模块设计 #

本模块要实现**记录用户的行为日志**

记录某个用户在什么时间点执行了什么操作,使用了什么方法,传递了什么参数,执行时长等

对用户的行为进行记录,查询,删除等操作

## 数据库设计 ##

用户行为记录表`sys_log`

| 字段名     | 类型     | 约束                | 说明         |
| ---------- | -------- | ------------------- | ------------ |
| id         | bigint   | **PRIMARY** **KEY** | id主键       |
| username   | varchar  |                     | 用户名       |
| operation  | varchar  |                     | 用户操作     |
| method     | varchar  |                     | 请求方法     |
| params     | varchar  |                     | 请求参数     |
| time       | bigint   |                     | 执行时长(ms) |
| createTime | datetime |                     | 创建时间     |

## 原型设计 ##

基于用户需求，实现静态页面(html/css/js)，通过静态页面为用户呈现基本需求实现

**说明:假如客户对此原型进行了确认,后续则可以基于此原型进行研发。**

我们要实现的业务和需求

当我们单击主页面`日志管理`按钮后,页面可以加载出日志管理的界面对日志进行增删改查等操作

## 1.1 日志查询 ##

### 1.1.1日志查询功能分析 ###

日志查询功能数据端基本架构分析

![image28-2023-9-1914:49:29.png](https://gitee.com/teamsea/tuchuang/raw/master/tuchuang/image28-2023-9-1914:49:29.png)

+ 我们查询的数据不仅仅有数据信息,还包括分页信息
+ 查询到的数据(数据,分页信息等)可以通过`vo`对象来进行包装
+ `Controller`向前端传递的数据有对错之分,通用一个`vo`对象来装其中信息

日志查询模块API架构分析

![image12-2023-9-1915:44:14.png](https://gitee.com/teamsea/tuchuang/raw/master/tuchuang/image12-2023-9-1915:44:14.png)

+ 在服务区端中我们编写的代码源头是`Controller`控制器,所有的业务都有控制器进行调用

  在业务层和持久层抛出的异常,最终会给到控制层

+ 控制层有一个全局异常处理类,被`@ControllerAdvice`进行修饰

  这个类可以处理控制层抛出的异常

![image5-2023-9-1916:18:10.png](https://gitee.com/teamsea/tuchuang/raw/master/tuchuang/image5-2023-9-1916:18:10.png)

+ 在持久层中,我们先查询行数后查询数据
+ 业务层封装了一个`vo(value object)`对象`PageObject`给控制层
+ 控制层封装了一个`vo(view object)`对象`JsonResult`传递到了前端

### 1.1.2 日志查询功能实现 ###

#### 实体对象设计与实现 ####

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class SysLog implements Serializable {
	private static final long serialVersionUID = 3594823546108659148L;
    // 和数据库中的属性一一对应
}
```

##### *###序列化* #####

 + 序列化与反序列化功能实现:可以参考这个篇文章
    [全方位解析Java的序列化 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/235394296)
  + 在Java中一般有关于存储的类(如String,ArrayList等)都会可实现序列化
  + 序列化的多应用在对象的保存,对象的网络传输等
  + 序列化ID不要随意的更改,序列化id的值是由编辑器自动生成的

  序列化测试

  ```java
  // 确定序列化文件的路径
  String fileName = "D:\\Java\\spring-boot-project\\CGB-DB-SYS-V1.01\\src\\main\\resources\\serializable\\SysLogObject.out";
  @Test
  	public void SerializableTest() throws Exception {
  		
  		// 创建一个SysLog对象 并 给予数据
  		SysLog log = new SysLog();
  		/**
  		*	为log对象属性赋值
  		*/
  		
  		// 对这个对象进行序列化
  		
  		//设置序列化文件
  		FileOutputStream fileOutputStream = new FileOutputStream(fileName);
  		
  		// 使用ObjectOutStream进行序列化
  		ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
  		objectOutputStream.writeObject(log); // 将对象序列化到制定的文件
  		
  		objectOutputStream.close();
  		System.out.println("序列化完毕");
  		
  	}
  
  ```

  反序列化测试

  ```java
  @Test
  	public void deserialization() throws Exception {
  		
  		// 获取序列化文件
  		FileInputStream fileInputStream = new FileInputStream(fileName);
  		
  		// 使用Object
  		ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
  		Object object = objectInputStream.readObject();// 将序列化文件转化为对象保存在内存中
  		
  		System.out.println(object);
  		
  	}
  ```

#### 持久层设计与实现 ####

我们查询的有两个数据:	总行数和记录

需要参数用户名,这个参数可以为空值,如果为空值则查询所有用户的数据

##### mapper接口设计 #####

```java
@Mapper
public interface SysLogDao {
    // 根据指定用户名查询总行数
	Integer getRowCount(String username);
    // 分页查询指定用户名的记录
	List<SysLog> findPageObject(String username, long startIndex, int pageSize);
}
```

##### SQL语句设计 #####

查询指定用户记录条数

如果用户名为空值,不执行where语句

```xml
<select id="getRowCount" resultType="int"> 
	select count(*) from sys_logs 
	<where>
		<if test="username!=null and username!=''">
			username like concat("%",#{username},"%")
		</if>
	</where>
</select>
```

分页查询指定用户信息

```xml
<select id="findPageObject" resultType="com.cy.pj.sys.entity.SysLog">	
	SELECT id, username, operation, `method`, params, `time`, ip, createdTime 
	FROM sys_logs
	<where>
		<if test="username!=null and username!=''">
			username like concat("%",#{username},"%")
		</if>
	</where>
	limit #{startIndex},#{pageSize}
</select>
```

#### 业务层设计与实现 ####

将查询到的数据打包到`vo(Value Object)`对象`PageObject`中,并且以Json格式传递到前端

这个对象中保存分页信息和记录信息

##### *###PageObject对象设计* #####

PageObject对象是一个`vo(Value Object)`

**什么是`vo(Value Object)`对象**

> Value Object 顾名思义，关注的是数据，因为它并没有唯一标识，如果两个 Value Object 的数据都一样，那么我们可以认为这两个 Value Object 就是同一个对象。

Value Object 具备的特性:

1. 没有唯一标识
2. 我们更加关注于它的数据属性

> 在此基础上我个人会再引申两个特性，具体的原因之后会详细说明:
>
> - ValueObject不会「单独存在」，而是附属于某个Entity
> - ValueObject的生命周期会与所附属的Entity绑定在一起



我们设计PageOBject对线要包含分页信息和记录数据

分页信息包括:

+ pageCurrent	页数
+ pageSize		   页面大小
+ rowCount		 总行数
+ pageCount	   总页数

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageObject<T> implements Serializable {
	private static final long serialVersionUID = 1536631092048817285L;
	/**
	* 分页信息
	*/
	
	/**
	 * 查询的数据
	 */
	private List<T> records;
	// 使用构造方法对属性赋值
	public PageObject(Long pageCurrent, Integer pageSize, Long rowCount, List<T> records) {
		super();
        // 页面总数需要进一步计算得出
		this.pageCount= (rowCount-1)/pageSize+1;
    }
}
```

##### 业务层接口 #####

向控制层传递`PageObject`对象

```java
public interface SysLogService {
	//指定用户的某一页信息
	PageObject<SysLog> finPageObject(String username, Long pageCurrent);
}
```

##### 业务层实现 #####

```java
/**
 * 通过用户名来查询某一页的信息
 *
 * @param username    用户名
 * @param pageCurrent 页码
 */
@Override
public PageObject<SysLog> finPageObject(String username, Long pageCurrent) {
	 // 这个方法分为四部分
	 // 1. 校验参数
	 // 2. 查询总数,校验参数
	 // 3. 查询记录
	 // 4. 封装数据
}
```

#### 控制层设计与实现 ####

##### *###JsonObject对象设计* #####

JsonObject对象是一个`vo(View Object)`

**什么是View Object**

> view object，又叫做视图对象，与之对应的是实体对象 entity object.
>
> 有的时候，没有必要把所有的信息都呈现给客户，只需要呈现部分数据给客户，这个时候，就会把这些必要的数据，封装在view object里抛到页面上去显示。

> VO是显示视图模型，视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。如果是一个DTO对应一个VO，则DTO=VO;但是如果一个DTO对应多个VO，则展示层需要把VO转换为服务层对应方法所要求的DTO，传送给服务层。从而达到服务层与展示层解耦的效果。



我们设计的JsonObject对象中包括这些属性

+ state 状态码
+ massage 消息
+ data 正确请求的获取的数据

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class JsonResult implements Serializable {

    private static final long serialVersionUID = 2080943344863436345L;
	
    /***
     * 包括的属性
     */
    
    // 当请求错误执行的方法
    public JsonResult(Throwable t){
        this.state = 0;
        this.message = t.getMessage();
    }

   // 当请求正确执行的方法
    public JsonResult(Object data){
        this.data = data; 
    }
}
```

##### 控制层实现 #####

```java
// 查询指定用户的某一页的日志数据
@RequestMapping("doFindPageObjects")
@ResponseBody
public JsonResult findPageObject(String username, Long pageCurrent) {
	
    PageObject<SysLog> data = service.finPageObject(username, pageCurrent);
       
	JsonResult result = new JsonResult(data);
    
	return result;
        
}
```

##### *###全局异常处理* #####

很多异常在开发过程中可以被try_catch掉,但是有些异常没有进行处理

这些异常会抛出到控制层,只能由控制层来处理

我么可以定义一个全局异常处理类型,来处理业务层和持久层抛出的异常

全局异常处理类被`@ControllerAdvice`注解修饰

```java
//整个项目的中可以抛出到前端的异常都可以由整个类来处理
@Log4j2
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(RuntimeException.class)
    @ResponseBody
    public JsonResult doHandleRuntimeException(RuntimeException exception) {
        log.info(exception.getMessage());
        return new JsonResult(exception);
    }

}
```

全局异常处理有两种方式

- 使用 @ControllerAdvice 和 @ExceptionHandler 注解
- 使用 ErrorController类 来实现

> 区别：
>
> @ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中
> ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误
> 如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常，ErrorController类 方式处理未进入控制器的异常
> @ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常信息，自由度更大。
>
> ------------------------------------------------
> 版权声明：本文为CSDN博主「熬夜复习」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/weixin_48530729/article/details/123412507

#### 前端页面展示 ####

数据传递到前端页面,进行展示

在start页面上加载doPageUI页面,并加载数据

```js
$(function(){
    //这里的回调函数参数不可以加'()'否则会立刻执行
   $("#pageId").load("doPageUI",doGetObjects)
})
```

##### ###load()函数 #####

> 载入远程 HTML 文件代码并插入至 DOM 中。
>
> 默认使用 GET 方式 - 传递附加参数时自动转换为 POST 方式。jQuery 1.2 中，可以指定选择符，来筛选载入的 HTML 文档，DOM 中将仅插入筛选出的 HTML 代码。语法形如 "url #some > selector"。请查看示例。

| 参数     | 解释                     |
| -------- | ------------------------ |
| url      | 远程HTML地址             |
| data     | 向远程地址传递的参数     |
| callback | 加载完毕后执行的回调函数 |

上述代码的含义是:

在id为pageId的标签中,引入doPageUI页面,完成后执行函数doGetObjcet

##### 获取数据分析并将数据展示到表格中 #####

```js
//执行分页查询
function doGetObject(){
    //1. 定义参数
    var params = {"pageCurrent" : 1}
    
    //2. 定义请求地址url
    var url = 'doFindPageObject'
    
    //3. 发送异步请求
    $.getJSON(url,params,function(result){
        console.log(result);
 		// 将数据放置到页面上
        doHandleResponseResult(result);
    })
}

function doHandleResponseResult(result){
    //验证状态信息
    if(result.state == 1 ){// 获取为正确的数据
        
        // 1.更新日志列表信息
        doSetTableBodyRows(result.data.records)
        // 2.更分页信息
        
    }else{// 获取为正确的数据
        alert(result.message);
    }
}

// 更新tbody日志列表信息
function doSetTableBodyRows(records){
	//1. 获取tbody,清空原有内容
	var tBody=$("#tbodyId");
	tBody.empty();
	//2. 迭代records对象并将内容追加到tbody中
	for(const r of records){
		// 构建tr对象
		var tr=$("<tr></tr>");
        // 构建tds对象
        var tds=doCreateTds(records[i]);
        // 将tds追加到tr中
        tr.append(tds);
        // 将tr追加到tbody中
        tBody.append(tr);
    }
}

// 将信息放置到表格中
function doCreateTds(data){
	var tds="<td><input type='checkbox' class='cBox' name='cItem' value='"+data.id+"'></td>"+       
    	"<td>"+data.username+"</td>"+
        "<td>"+data.operation+"</td>"+
        "<td>"+data.method+"</td>"+
        "<td>"+data.params+"</td>"+
        "<td>"+data.ip+"</td>"+
        "<td>"+data.time+"</td>";          
    	
    return tds;
}
```

##### 分页菜单实现 #####



## 1.2 日志删除 ##

## 1.3 日志添加 ##