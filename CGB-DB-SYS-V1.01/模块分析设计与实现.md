# 模块分析设计与实现 #

# 1.日志模块设计 #

## 1.1 日志查询 ##

### 1.1.1日志查询功能分析 ###

日志查询功能数据端基本架构分析

![image28-2023-9-1914:49:29.png](https://gitee.com/teamsea/tuchuang/raw/master/tuchuang/image28-2023-9-1914:49:29.png)

+ 我们查询的数据不仅仅有数据信息,还包括分页信息
+ 查询到的数据(数据,分页信息等)可以通过`vo`对象来进行包装
+ `Controller`向前端传递的数据有对错之分,通用一个`vo`对象来装其中信息

日志查询模块API架构分析

![image12-2023-9-1915:44:14.png](https://gitee.com/teamsea/tuchuang/raw/master/tuchuang/image12-2023-9-1915:44:14.png)

+ 在服务区端中我们编写的代码源头是`Controller`控制器,所有的业务都有控制器进行调用

  在业务层和持久层抛出的异常,最终会给到控制层

+ 控制层有一个全局异常处理类,被`@ControllerAdvice`进行修饰

  这个类可以处理控制层抛出的异常

![image5-2023-9-1916:18:10.png](https://gitee.com/teamsea/tuchuang/raw/master/tuchuang/image5-2023-9-1916:18:10.png)

+ 在持久层中,我们先查询行数后查询数据
+ 业务层封装了一个`vo(value object)`对象`PageObject`给控制层
+ 控制层封装了一个`vo(view object)`对象`JsonResult`传递到了前端

### 1.1.2 日志查询功能实现 ###

#### 实体对象设计与实现 ####

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class SysLog implements Serializable {
	private static final long serialVersionUID = 3594823546108659148L;
    // 和数据库中的属性一一对应
}
```

##### *###序列化* #####

 + 序列化与反序列化功能实现:可以参考这个篇文章
    [全方位解析Java的序列化 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/235394296)
  + 在Java中一般有关于存储的类(如String,ArrayList等)都会可实现序列化
  + 序列化的多应用在对象的保存,对象的网络传输等
  + 序列化ID不要随意的更改,序列化id的值是由编辑器自动生成的

  序列化测试

  ```java
  // 确定序列化文件的路径
  String fileName = "D:\\Java\\spring-boot-project\\CGB-DB-SYS-V1.01\\src\\main\\resources\\serializable\\SysLogObject.out";
  @Test
  	public void SerializableTest() throws Exception {
  		
  		// 创建一个SysLog对象 并 给予数据
  		SysLog log = new SysLog();
  		/**
  		*	为log对象属性赋值
  		*/
  		
  		// 对这个对象进行序列化
  		
  		//设置序列化文件
  		FileOutputStream fileOutputStream = new FileOutputStream(fileName);
  		
  		// 使用ObjectOutStream进行序列化
  		ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
  		objectOutputStream.writeObject(log); // 将对象序列化到制定的文件
  		
  		objectOutputStream.close();
  		System.out.println("序列化完毕");
  		
  	}
  
  ```

  反序列化测试

  ```java
  @Test
  	public void deserialization() throws Exception {
  		
  		// 获取序列化文件
  		FileInputStream fileInputStream = new FileInputStream(fileName);
  		
  		// 使用Object
  		ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
  		Object object = objectInputStream.readObject();// 将序列化文件转化为对象保存在内存中
  		
  		System.out.println(object);
  		
  	}
  ```

#### 持久层设计与实现 ####

我们查询的有两个数据:	总行数和记录

需要参数用户名,这个参数可以为空值,如果为空值则查询所有用户的数据

##### mapper接口设计 #####

```java
@Mapper
public interface SysLogDao {
    // 根据指定用户名查询总行数
	Integer getRowCount(String username);
    // 分页查询指定用户名的记录
	List<SysLog> findPageObject(String username, long startIndex, int pageSize);
}
```

##### SQL语句设计 #####

查询指定用户记录条数

如果用户名为空值,不执行where语句

```xml
<select id="getRowCount" resultType="int"> 
	select count(*) from sys_logs 
	<where>
		<if test="username!=null and username!=''">
			username like concat("%",#{username},"%")
		</if>
	</where>
</select>
```

分页查询指定用户信息

```xml
<select id="findPageObject" resultType="com.cy.pj.sys.entity.SysLog">	
	SELECT id, username, operation, `method`, params, `time`, ip, createdTime 
	FROM sys_logs
	<where>
		<if test="username!=null and username!=''">
			username like concat("%",#{username},"%")
		</if>
	</where>
	limit #{startIndex},#{pageSize}
</select>
```

#### 业务层设计与实现 ####

将查询到的数据打包到`vo(Value Object)`对象`PageObject`中

这个对象中保存分页信息和记录信息

##### *###PageObject对象设计* #####

PageObject对象是一个`vo(Value Object)`

**什么是`vo(Value Object)`对象**

> Value Object 顾名思义，关注的是数据，因为它并没有唯一标识，如果两个 Value Object 的数据都一样，那么我们可以认为这两个 Value Object 就是同一个对象。

Value Object 具备的特性:

1. 没有唯一标识
2. 我们更加关注于它的数据属性

> 在此基础上我个人会再引申两个特性，具体的原因之后会详细说明:
>
> - ValueObject不会「单独存在」，而是附属于某个Entity
> - ValueObject的生命周期会与所附属的Entity绑定在一起



我们设计PageOBject对线要包含分页信息和记录数据

分页信息包括:

+ pageCurrent	页数
+ pageSize		   页面大小
+ rowCount		 总行数
+ pageCount	   总页数

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageObject<T> implements Serializable {
	private static final long serialVersionUID = 1536631092048817285L;
	/**
	* 分页信息
	*/
	
	/**
	 * 查询的数据
	 */
	private List<T> records;
	// 使用构造方法对属性赋值
	public PageObject(Long pageCurrent, Integer pageSize, Long rowCount, List<T> records) {
		super();
        // 页面总数需要进一步计算得出
		this.pageCount= (rowCount-1)/pageSize+1;
    }
}
```

##### 业务层接口 #####

向控制层传递`PageObject`对象

```java
public interface SysLogService {
	//指定用户的某一页信息
	PageObject<SysLog> finPageObject(String username, Long pageCurrent);
}
```

##### 业务层实现 #####

```java
/**
 * 通过用户名来查询某一页的信息
 *
 * @param username    用户名
 * @param pageCurrent 页码
 */
@Override
public PageObject<SysLog> finPageObject(String username, Long pageCurrent) {
	 // 这个方法分为四部分
	 // 1. 校验参数
	 // 2. 查询总数,校验参数
	 // 3. 查询记录
	 // 4. 封装数据
}
```

#### 控制层设计与实现 ####

##### *###JsonObject对象设计* #####

JsonObject对象是一个`vo(View Object)`

**什么是View Object**

> view object，又叫做视图对象，与之对应的是实体对象 entity object.
>
> 有的时候，没有必要把所有的信息都呈现给客户，只需要呈现部分数据给客户，这个时候，就会把这些必要的数据，封装在view object里抛到页面上去显示。

> VO是显示视图模型，视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。如果是一个DTO对应一个VO，则DTO=VO;但是如果一个DTO对应多个VO，则展示层需要把VO转换为服务层对应方法所要求的DTO，传送给服务层。从而达到服务层与展示层解耦的效果。



我们设计的JsonObject对象中包括这些属性

+ state 状态码
+ massage 消息
+ data 正确请求的获取的数据

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class JsonResult implements Serializable {

    private static final long serialVersionUID = 2080943344863436345L;
	
    /***
     * 包括的属性
     */
    
    // 当请求错误执行的方法
    public JsonResult(Throwable t){
        this.state = 0;
        this.message = t.getMessage();
    }

   // 当请求正确执行的方法
    public JsonResult(Object data){
        this.data = data; 
    }
}
```

##### 控制层实现 #####

```java
// 查询指定用户的某一页的日志数据
@RequestMapping("doFindPageObjects")
@ResponseBody
public JsonResult findPageObject(String username, Long pageCurrent) {
	
    PageObject<SysLog> data = service.finPageObject(username, pageCurrent);
       
	JsonResult result = new JsonResult(data);
    
	return result;
        
}
```

##### *###全局异常处理* #####

## 1.2 日志删除 ##

## 1.3 日志添加 ##